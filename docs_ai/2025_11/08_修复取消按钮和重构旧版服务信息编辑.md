# 修复取消按钮和重构旧版服务信息编辑

**日期**: 2025年11月08日  
**操作**: 修复用户基本信息取消按钮失效问题，重构旧版服务信息编辑功能，修改接口为 PUT

## 问题描述

1. **用户基本信息卡片**：点击编辑按钮后，取消按钮无法恢复到原始数据状态
2. **旧版服务信息卡片**：编辑方式不统一，使用弹窗方式编辑流量值，需要重构为内联编辑模式
3. **API 接口问题**：使用 PATCH 接口时存在空数据问题，需改为 PUT 接口

## 修复内容

### 1. 修复用户基本信息取消按钮

**文件**: `/lib/component/low_admin/editable_user_v2_info_card_component.dart`

#### 问题根源

- 在 `initState()` 中直接创建了 `TextEditingController` 实例并初始化值
- `_cancelEdit()` 调用 `_initializeControllers()` 时尝试重新创建 controller，导致状态混乱

#### 解决方案

1. 在 `initState()` 中只创建空的 controller
2. 将 `_initializeControllers()` 改为只更新 controller 的值，而不是重新创建
3. 这样取消编辑时，可以正确地从 `widget.userData` 恢复原始值

```dart
@override
void initState() {
  super.initState();
  _emailController = TextEditingController();
  _userNameController = TextEditingController();
  _telegramIdController = TextEditingController();
  _initializeControllers();
}

void _initializeControllers() {
  final user = widget.userData;
  _emailController.text = user?.email ?? '';
  _userNameController.text = user?.userName ?? '';
  _telegramIdController.text = user?.telegramId?.toString() ?? '';
  _isEnable = user?.isEnable ?? true;
  _isEmailVerify = user?.isEmailVerify ?? false;
  _userAccountExpireIn = user?.userAccountExpireIn.toLocal() ??
      DateTime.now().add(const Duration(days: 365));
}
```

### 2. 重构旧版服务信息编辑功能

**文件**: `/lib/component/low_admin/editable_user_old_service_card_component.dart`

#### 重构内容

完全重构为与用户基本信息卡片一致的编辑模式：

1. **移除弹窗编辑模式**
    - 删除 `_TrafficEditDialog` 及相关代码
    - 删除 `_editTraffic()` 方法

2. **实现内联编辑模式**
    - 添加编辑/取消/保存按钮到卡片标题栏
    - 点击编辑按钮切换到编辑模式
    - 取消按钮恢复原始数据
    - 保存按钮提交所有修改

3. **流量字段双输入框同步**
   每个流量字段提供两个输入框：
    - **人类可读格式**：支持 GB、MB 等单位输入
    - **原始字节数**：显示和编辑原始 int 值
    - 两个输入框实时同步转换

4. **支持编辑的字段**
    - ✅ 上传流量（双输入框）
    - ✅ 下载流量（双输入框）
    - ✅ 总流量限制（双输入框）
    - ✅ 昨日使用流量（双输入框）
    - ✅ 用户等级
    - ✅ 等级过期时间（日期时间选择器）
    - ✅ 连接限速（原始字节数，1073741824 字节 = 1 Mbps）
    - ✅ 连接数量
    - ✅ 管理员设置重置日（0 为未启用）
    - ✅ 管理员设置自动重置流量值（双输入框）

5. **字段显示优化**
    - **连接限速**：
        - 编辑时：双输入框（人类可读格式 + 原始字节数），实时同步转换
        - 显示时：自动转换为 Mbps，同时显示原始字节数
        - 例：编辑时输入 "1 GB" 或 "1073741824"，显示时显示 `1.00 Mbps (1073741824 字节)`
        - 提示信息：`1073741824 字节 = 1 Mbps`
    - **管理员设置重置日**：
        - 编辑时：提示 "每月重置流量的日期（1-31），0 为未启用"
        - 显示时：0 显示为"未启用"，其他显示为"每月X日"
    - **管理员设置自动重置流量值**：
        - 支持双输入框（人类可读 + 原始字节数）
        - 0 显示为"未设置"

#### 新增功能

**流量输入框同步方法**:

```dart
void _syncTrafficControllers(TextEditingController humanController,
    TextEditingController rawController,
    String value,
    bool isHumanEditing) {
  if (isHumanEditing) {
    final bytes = parseBytes(value);
    if (bytes != null) {
      rawController.text = bytes.toString();
    }
  } else {
    final bytes = int.tryParse(value);
    if (bytes != null) {
      humanController.text = formatBytes(bytes);
    }
  }
}
```

**流量编辑UI组件**:

```dart
Widget _buildTrafficEditSection(String label,
    TextEditingController humanController,
    TextEditingController rawController,
    IconData icon, {
      String? helperText, // 可选的自定义提示文本
    }) {
  return Card(
    elevation: 1,
    child: Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        children: [
          // 标题
          Row(children: [Icon(icon), Text(label)]),
          // 人类可读输入框
          TextField(
            controller: humanController,
            decoration: InputDecoration(
              labelText: '人类可读格式',
              helperText: '例: 10.5 GB, 1024 MB',
            ),
            onChanged: (value) =>
                _syncTrafficControllers(
                  humanController, rawController, value, true,
                ),
          ),
          // 原始字节数输入框
          TextField(
            controller: rawController,
            decoration: InputDecoration(
              labelText: '原始字节数',
              helperText: helperText ?? '单位: Bytes', // 使用自定义提示或默认提示
            ),
            keyboardType: TextInputType.number,
            onChanged: (value) =>
                _syncTrafficControllers(
                  humanController, rawController, value, false,
                ),
          ),
        ],
      ),
    ),
  );
}
```

此组件用于所有流量相关字段的双向绑定编辑，包括：

- 上传流量、下载流量、总流量限制、昨日使用流量
- **连接限速**（带自定义 helperText: "1073741824 字节 = 1 Mbps"）
- 管理员设置自动重置流量值

### 3. 修改 API 接口为 PUT

**文件**: `/lib/page/low_admin/user_detail/low_admin_user_detail_page.dart`

#### 问题原因

- 使用 PATCH 接口时，未提供的字段可能会被设置为 null
- 导致数据丢失或不一致的问题

#### 解决方案

将 `_updateUserOldService` 方法从使用 PATCH 接口改为 PUT 接口：

**修改前**：

```dart
Future<bool> _updateUserOldService(Map<String, dynamic> data) async {
  final body = WebSubFastapiRoutersApiVLowAdminApiUserOldServiceParamModelPatch(
    ssUploadSize: data['ssUploadSize'] as int?,
    ssDownloadSize: data['ssDownloadSize'] as int?,
    // ... 其他字段都是可选的
  );

  final response = await _restClient.fallback
      .patchUserOldServiceApiV2LowAdminApiUserOldServiceUserIdPatch(
    userId: widget.userId,
    body: body,
  );
  // ...
}
```

**修改后**：

```dart
Future<bool> _updateUserOldService(Map<String, dynamic> data) async {
  final body = WebSubFastapiRoutersApiVLowAdminApiUserOldServiceParamModelPut(
    ssUploadSize: data['ssUploadSize'] as int,
    ssDownloadSize: data['ssDownloadSize'] as int,
    ssBandwidthTotalSize: data['ssBandwidthTotalSize'] as int,
    userLevelExpireIn: (data['userLevelExpireIn'] as DateTime).toUtc(),
    ssBandwidthYesterdayUsedSize:
    data['ssBandwidthYesterdayUsedSize'] as int? ?? 0,
    userLevel: data['userLevel'] as int? ?? 0,
    nodeConnector: data['nodeConnector'] as int? ?? 0,
    autoResetDay: data['autoResetDay'] as int? ?? 0,
    autoResetBandwidth: data['autoResetBandwidth'] as num? ?? 0.0,
    nodeSpeedLimit: data['nodeSpeedLimit'] as int?,
    ssLastUsedTime: _userOldServiceData?.ssLastUsedTime,
    lastCheckInTime: _userOldServiceData?.lastCheckInTime,
  );

  final response = await _restClient.fallback
      .putUserOldServiceApiV2LowAdminApiUserOldServiceUserIdPut(
    userId: widget.userId,
    body: body,
  );
  // ...
}
```

#### 关键变化

1. ✅ 使用 `ParamModelPut` 替代 `ParamModelPatch`
2. ✅ 使用 `putUserOldServiceApiV2LowAdminApiUserOldServiceUserIdPut` 替代
   `patchUserOldServiceApiV2LowAdminApiUserOldServiceUserIdPatch`
3. ✅ 必填字段不再是可选的（`int` 而不是 `int?`）
4. ✅ 为所有可选字段提供默认值（`?? 0`）
5. ✅ 保留原有的时间戳字段（`ssLastUsedTime` 和 `lastCheckInTime`）

## 技术细节

### Controller 管理

- 所有 TextEditingController 在 `initState()` 创建空实例
- `_initializeControllers()` 只更新值，不创建新实例
- `_cancelEdit()` 调用 `_initializeControllers()` 恢复原始值
- `dispose()` 中正确释放所有 controller

### 时间处理

遵循项目的 DateTime 规范：

- API 返回 UTC 时间
- 编辑时转换为本地时间：`.toLocal()`
- 提交前转换回 UTC：`.toUtc()`

### 状态管理

- `_isEditing`: 控制显示/编辑模式切换
- `_isSaving`: 保存时禁用所有输入和按钮
- 编辑模式下显示取消和保存按钮
- 显示模式下只显示编辑按钮

## 改进效果

### 用户体验提升

1. ✅ 取消按钮现在可以正确恢复原始数据
2. ✅ 统一的编辑体验（用户基本信息 + 旧版服务信息）
3. ✅ 所有字段都可以在一个界面上编辑
4. ✅ 流量值支持人性化输入（10 GB）和精确输入（10737418240）
5. ✅ 实时同步转换，避免手动计算
6. ✅ 编辑时有明确的保存/取消操作
7. ✅ 使用 PUT 接口，避免数据丢失问题

### 代码质量提升

1. ✅ 遵循 Flutter 开发规范
2. ✅ 使用最精简的方法实现功能
3. ✅ 避免无意义的 try-catch
4. ✅ Controller 生命周期管理正确
5. ✅ 代码结构清晰，易于维护
6. ✅ API 调用更加安全可靠（PUT 替代 PATCH）

### 数据安全性提升

1. ✅ PUT 接口要求提供所有必填字段
2. ✅ 避免 PATCH 接口可能导致的字段丢失
3. ✅ 保留原有的时间戳字段（ssLastUsedTime、lastCheckInTime）
4. ✅ 所有可选字段都有明确的默认值

## 测试建议

1. **取消按钮测试**
    - 点击编辑 → 修改内容 → 点击取消 → 验证数据恢复
    - 多次编辑取消，确保状态一致

2. **流量输入同步测试**
    - 在人类可读框输入 "10 GB" → 验证原始框显示 "10737418240"
    - 在原始框输入 "1073741824" → 验证人类可读框显示 "1.00 GB"
    - 测试各种单位：B, KB, MB, GB, TB

3. **完整编辑流程测试**
    - 修改所有字段 → 保存 → 验证 API 调用正确
    - 修改部分字段 → 取消 → 验证未保存
    - 保存时网络错误 → 验证错误提示

4. **API 接口测试**
    - 验证使用 PUT 接口后所有字段都被正确保存
    - 验证未修改的字段保持原值不变
    - 验证时间戳字段（ssLastUsedTime、lastCheckInTime）不会丢失

## 相关文件

- `/lib/component/low_admin/editable_user_v2_info_card_component.dart` - 用户基本信息卡片
- `/lib/component/low_admin/editable_user_old_service_card_component.dart` - 旧版服务信息卡片
- `/lib/page/low_admin/user_detail/low_admin_user_detail_page.dart` - 用户详情页
- `/lib/helper/format_helper.dart` - 字节格式化工具函数

## 注意事项

1. 所有流量字段使用 `int` 类型（字节数）
2. `autoResetBandwidth` 在 API 中是 `num` 类型，需要转换为 `int`
3. 时间字段需要进行 UTC/本地时间转换
4. 保存失败时保持编辑状态，方便用户修正
5. **使用 PUT 接口替代 PATCH**：PUT 要求提供所有必填字段，确保数据完整性
6. **保留时间戳字段**：`ssLastUsedTime` 和 `lastCheckInTime` 从原数据中获取，避免丢失

